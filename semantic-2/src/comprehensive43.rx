// comprehensive43.rx - Simple Stack-Based Interpreter
// This test comprehensively evaluates compiler optimizations for:
// - Large switch-like dispatch loops for instruction processing.
// - Array manipulation for stack and program memory.
// - Deeply nested function calls and recursion simulation.
// - Complex conditional logic for jumps and control flow.
// - Performance of integer arithmetic and comparisons.
// - Mutability analysis in functions modifying shared state.

fn main() {
    let mut program: [i32; 256] = [0; 256];
    let mut stack: [i32; 256] = [0; 256];
    let mut sp: i32 = -1;
    let mut pc: i32 = 0;
    let mut halt: bool = false;

    // Opcodes: 1:PUSH, 2:POP, 3:ADD, 4:SUB, 5:MUL, 6:DIV, 7:JMP, 8:JZ, 9:JNZ, 10:EQ, 11:LT, 12:GT, 13:PRINT, 14:HALT, 15:DUP

    fn load_program(mut prog: &mut [i32; 256]) {
        // Calculate factorial of 8
        prog[0] = 1; prog[1] = 8;       // PUSH 8 (n)
        prog[2] = 1; prog[3] = 1;       // PUSH 1 (result)
        // Loop start (pc=4)
        prog[4] = 15;                   // DUP (duplicate n)
        prog[5] = 1; prog[6] = 1;       // PUSH 1
        prog[7] = 11;                   // LT (n < 1?)
        prog[8] = 9; prog[9] = 14;      // JNZ to loop_end (pc=18)
        // if n < 1, jump to print
        prog[10] = 7; prog[11] = 20;     // JMP to print_result (pc=30)
        // loop_body (pc=12)
        prog[12] = 5;                   // MUL (result = result * n)
        prog[13] = 1; prog[14] = -1;    // PUSH -1
        prog[15] = 3;                   // ADD (n = n - 1)
        prog[16] = 7; prog[17] = 4;      // JMP to loop_start (pc=4)
        // loop_end (pc=18)
        prog[18] = 2;                   // POP (n)
        prog[19] = 7; prog[20] = 12;     // JMP to loop_body (pc=12)
        // print_result (pc=21)
        prog[21] = 13;                  // PRINT result
        prog[22] = 14;                  // HALT

        // Some dead code to increase complexity
        let mut i: i32 = 30;
        while i < 250 {
            prog[i] = 1;
            prog[i+1] = i;
            prog[i+2] = 15;
            prog[i+3] = 2;
            i = i + 4;
        }
    }

    // Hidden Error: This function is declared to take an immutable program array,
    // but it tries to modify it. This should cause a mutability conflict error.
    fn self_modify_code(mut prog: &[i32; 256], pc: i32) {
        if pc > 10 && prog[pc-1] == 15 { // If previous instruction was DUP
            prog[pc] = 2; // Change next instruction to POP
        }
    }

    load_program(&mut program);

    while !halt {
        let instruction: i32 = program[pc];
        pc = pc + 1;

        // This call introduces the hidden error.
        self_modify_code(&program, pc);

        if instruction == 1 { // PUSH
            let value: i32 = program[pc];
            pc = pc + 1;
            sp = sp + 1;
            stack[sp] = value;
        } else if instruction == 2 { // POP
            sp = sp - 1;
        } else if instruction == 3 { // ADD
            let b: i32 = stack[sp];
            sp = sp - 1;
            let a: i32 = stack[sp];
            stack[sp] = a + b;
        } else if instruction == 4 { // SUB
            let b: i32 = stack[sp];
            sp = sp - 1;
            let a: i32 = stack[sp];
            stack[sp] = a - b;
        } else if instruction == 5 { // MUL
            let b: i32 = stack[sp];
            sp = sp - 1;
            let a: i32 = stack[sp];
            stack[sp] = a * b;
        } else if instruction == 6 { // DIV
            let b: i32 = stack[sp];
            sp = sp - 1;
            let a: i32 = stack[sp];
            stack[sp] = a / b;
        } else if instruction == 7 { // JMP
            pc = program[pc];
        } else if instruction == 8 { // JZ
            let val: i32 = stack[sp];
            sp = sp - 1;
            if val == 0 {
                pc = program[pc];
            } else {
                pc = pc + 1;
            }
        } else if instruction == 9 { // JNZ
            let val: i32 = stack[sp];
            sp = sp - 1;
            if val != 0 {
                pc = program[pc];
            } else {
                pc = pc + 1;
            }
        } else if instruction == 10 { // EQ
            let b: i32 = stack[sp];
            sp = sp - 1;
            let a: i32 = stack[sp];
            if a == b { stack[sp] = 1; } else { stack[sp] = 0; }
        } else if instruction == 11 { // LT
            let b: i32 = stack[sp];
            sp = sp - 1;
            let a: i32 = stack[sp];
            if a < b { stack[sp] = 1; } else { stack[sp] = 0; }
        } else if instruction == 12 { // GT
            let b: i32 = stack[sp];
            sp = sp - 1;
            let a: i32 = stack[sp];
            if a > b { stack[sp] = 1; } else { stack[sp] = 0; }
        } else if instruction == 13 { // PRINT
            printInt(stack[sp]);
        } else if instruction == 14 { // HALT
            halt = true;
        } else if instruction == 15 { // DUP
            let val: i32 = stack[sp];
            sp = sp + 1;
            stack[sp] = val;
        }

        if pc < 0 || pc >= 256 {
            halt = true;
        }
    }
}
