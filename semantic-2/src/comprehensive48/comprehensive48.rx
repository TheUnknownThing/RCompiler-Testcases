/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Success
Test Name: Advanced Logistics and Supply Chain Simulation
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Management of complex, nested data structures for inventory and orders
Optimization of array-heavy operations for stock management
Branch prediction and optimization in complex conditional logic for order processing
Function call optimization in a deeply nested call graph
Integer arithmetic and data flow analysis in a simulated environment
Corner case handling for stock levels (e.g., zero stock, backorders)
*/

// comprehensive48.rx - Advanced Logistics and Supply Chain Simulation
// This test comprehensively evaluates compiler optimizations for:
// - Management of complex, nested data structures for inventory and orders
// - Optimization of array-heavy operations for stock management
// - Branch prediction and optimization in complex conditional logic for order processing
// - Function call optimization in a deeply nested call graph
// - Integer arithmetic and data flow analysis in a simulated environment
// - Corner case handling for stock levels (e.g., zero stock, backorders)

fn main() {
    let mut warehouse_stock_A: i32;
    let mut warehouse_stock_B: i32;
    let mut warehouse_stock_C: i32;
    warehouse_stock_A = 1000;
    warehouse_stock_B = 1500;
    warehouse_stock_C = 800;

    let mut pending_orders_A: i32;
    let mut pending_orders_B: i32;
    let mut pending_orders_C: i32;
    pending_orders_A = 0;
    pending_orders_B = 0;
    pending_orders_C = 0;

    let mut processed_orders: i32;
    processed_orders = 0;
    let mut total_revenue: i32;
    total_revenue = 0;

    let price_A: i32;
    let price_B: i32;
    let price_C: i32;
    price_A = 10;
    price_B = 15;
    price_C = 20;

    let mut i: i32;
    i = 0;
    while (i < 200) {
        let order_type: i32;
        order_type = i % 3;
        let order_quantity: i32;
        order_quantity = (i * 7 + 15) % 50 + 10;

        if (order_type == 0) {
            pending_orders_A = pending_orders_A + order_quantity;
        } else {
            if (order_type == 1) {
                pending_orders_B = pending_orders_B + order_quantity;
            } else {
                pending_orders_C = pending_orders_C + order_quantity;
            }
        }

        if (i % 10 == 0) {
            warehouse_stock_A = warehouse_stock_A + 200;
            warehouse_stock_B = warehouse_stock_B + 300;
            warehouse_stock_C = warehouse_stock_C + 150;
        }

        let mut can_process_A: bool;
        let mut can_process_B: bool;
        let mut can_process_C: bool;
        can_process_A = false;
        can_process_B = false;
        can_process_C = false;

        if (pending_orders_A > 0) {
            if (warehouse_stock_A >= pending_orders_A) {
                can_process_A = true;
            }
        }
        if (pending_orders_B > 0) {
            if (warehouse_stock_B >= pending_orders_B) {
                can_process_B = true;
            }
        }
        if (pending_orders_C > 0) {
            if (warehouse_stock_C >= pending_orders_C) {
                can_process_C = true;
            }
        }

        if (can_process_A) {
            let mut revenue_A: i32;
            revenue_A = 0;
            if (pending_orders_A > 50) {
                let discount: i32;
                discount = 5;
                revenue_A = pending_orders_A * (price_A - discount);
                let special_bonus: i32;
                special_bonus = 100;
            } else {
                revenue_A = pending_orders_A * price_A;
            }
            warehouse_stock_A = warehouse_stock_A - pending_orders_A;
            total_revenue = total_revenue + revenue_A;
            processed_orders = processed_orders + pending_orders_A;
            pending_orders_A = 0;
        }

        if (can_process_B) {
            let mut revenue_B: i32;
            revenue_B = 0;
            if (pending_orders_B > 40) {
                let discount: i32;
                discount = 3;
                revenue_B = pending_orders_B * (price_B - discount);
            } else {
                revenue_B = pending_orders_B * price_B;
            }
            warehouse_stock_B = warehouse_stock_B - pending_orders_B;
            total_revenue = total_revenue + revenue_B;
            processed_orders = processed_orders + pending_orders_B;
            pending_orders_B = 0;
        }

        if (can_process_C) {
            let mut revenue_C: i32;
            revenue_C = 0;
            if (pending_orders_C > 30) {
                let discount: i32;
                discount = 2;
                revenue_C = pending_orders_C * (price_C - discount);
            } else {
                revenue_C = pending_orders_C * price_C;
            }
            warehouse_stock_C = warehouse_stock_C - pending_orders_C;
            total_revenue = total_revenue + revenue_C;
            processed_orders = processed_orders + pending_orders_C;
            pending_orders_C = 0;
        }

        if (i % 25 == 0) {
            let mut audit_result: i32;
            audit_result = perform_audit(warehouse_stock_A, warehouse_stock_B, warehouse_stock_C, total_revenue);
            if (audit_result < 0) {
                total_revenue = total_revenue + special_bonus; // Compile Error: special_bonus is not in scope here
            }
        }

        i = i + 1;
    }

    printInt(total_revenue);
    printInt(processed_orders);
    printInt(warehouse_stock_A);
    printInt(warehouse_stock_B);
    printInt(warehouse_stock_C);
}

fn perform_audit(stock_a: i32, stock_b: i32, stock_c: i32, revenue: i32) -> i32 {
    let mut score: i32;
    score = 0;
    if (stock_a < 100) {
        score = score - 10;
    } else {
        score = score + 5;
    }
    if (stock_b < 150) {
        score = score - 10;
    } else {
        score = score + 5;
    }
    if (stock_c < 80) {
        score = score - 10;
    } else {
        score = score + 5;
    }

    if (revenue > 50000) {
        score = score + 20;
    } else {
        if (revenue > 20000) {
            score = score + 10;
        }
    }

    let mut i: i32;
    i = 0;
    let mut temp_rev: i32;
    temp_rev = revenue;
    while (i < 5) {
        temp_rev = temp_rev / (i + 1);
        i = i + 1;
    }
    score = score + temp_rev % 10;

    if (score > 15) {
        return 1;
    } else {
        if (score > 0) {
            return 0;
        } else {
            return -1;
        }
    }
}

fn another_level_of_processing(data: i32, factor: i32) -> i32 {
    let mut i: i32;
    i = 0;
    let mut result: i32;
    result = data;
    while (i < 10) {
        if (i % 2 == 0) {
            result = result + (factor * i);
        } else {
            result = result - (factor * i / 2);
        }
        let mut j: i32;
        j = 0;
        while (j < 5) {
            result = result + j;
            j = j + 1;
        }
        i = i + 1;
    }
    return result;
}

fn yet_another_function(val1: i32, val2: i32) -> i32 {
    let mut intermediate: i32;
    if (val1 > val2) {
        intermediate = val1 - val2;
    } else {
        intermediate = val2 - val1;
    }

    let mut k: i32;
    k = 0;
    while (k < 5) {
        intermediate = another_level_of_processing(intermediate, k + 1);
        k = k + 1;
    }

    if (intermediate > 1000) {
        return 1000;
    }
    return intermediate;
}

fn process_complex_data(a: i32, b: i32, c: i32) -> i32 {
    let mut res1: i32;
    res1 = yet_another_function(a, b);
    let mut res2: i32;
    res2 = yet_another_function(b, c);
    let mut res3: i32;
    res3 = yet_another_function(a, c);

    let mut final_val: i32;
    final_val = res1 + res2 + res3;

    let mut i: i32;
    i = 0;
    while (i < 10) {
        final_val = final_val - i * i;
        i = i + 1;
    }
    return final_val;
}

fn simulate_external_factors(current_rev: i32) -> i32 {
    let market_condition: i32;
    market_condition = current_rev % 5;
    let mut adjustment: i32;
    adjustment = 0;

    if (market_condition == 0) {
        adjustment = -500;
    } else {
        if (market_condition == 1) {
            adjustment = 200;
        } else {
            if (market_condition == 2) {
                adjustment = 0;
            } else {
                if (market_condition == 3) {
                    adjustment = 1000;
                } else {
                    adjustment = -100;
                }
            }
        }
    }
    return adjustment;
}

fn final_check(stock_a: i32, stock_b: i32, stock_c: i32, revenue: i32) -> i32 {
    let mut score: i32;
    score = 0;
    if (stock_a > 500) {
        score = score + 1;
    }
    if (stock_b > 800) {
        score = score + 1;
    }
    if (stock_c > 400) {
        score = score + 1;
    }
    if (revenue > 100000) {
        score = score + 2;
    }
    return score;
}
