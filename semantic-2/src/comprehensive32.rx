// comprehensive32.rx - Text Processing and Pattern Matching Engine
// This test comprehensively evaluates compiler optimizations for:
// - Complex state machine logic for pattern matching.
// - Large array traversals for text processing.
// - Nested loops and conditionals for finding sub-patterns.
// - Function calls with multiple array-based arguments.
// - Branch prediction in text analysis loops.

fn printInt(n: i32) {}

const TEXT_SIZE: i32 = 1024;
const PATTERN_SIZE: i32 = 64;

fn main() {
    let mut text: [i32; TEXT_SIZE] = [0; TEXT_SIZE];
    generate_text(&mut text, 12345);

    let mut pattern1: [i32; PATTERN_SIZE] = [0; PATTERN_SIZE];
    let pattern1_len: i32 = 3;
    pattern1[0] = 65; pattern1[1] = 66; pattern1[2] = 67;

    let mut pattern2: [i32; PATTERN_SIZE] = [0; PATTERN_SIZE];
    let pattern2_len: i32 = 5;
    pattern2[0] = 88; pattern2[1] = 89; pattern2[2] = 90; pattern2[3] = 88; pattern2[4] = 89;

    let mut pattern3: [i32; PATTERN_SIZE] = [0; PATTERN_SIZE];
    let pattern3_len: i32 = 2;
    pattern3[0] = 100; pattern3[1] = 100;

    let mut count1: i32 = find_pattern(&text, &pattern1, pattern1_len);
    printInt(count1);

    let mut count2: i32 = find_pattern_with_wildcard(&text, &pattern2, pattern2_len, 90);
    printInt(count2);

    let mut count3: i32 = find_complex_pattern(&text);
    printInt(count3);

    let mut result: i32 = analyze_text_frequency(&text);
    printInt(result);

    let mut error_res: i32 = trigger_error_path(&text, &pattern1, pattern1_len);
    printInt(error_res);

    printInt(9999);
}

fn generate_text(text: &mut [i32; TEXT_SIZE], seed: i32) {
    let mut current_seed: i32 = seed;
    let mut i: i32 = 0;
    while i < TEXT_SIZE {
        current_seed = (current_seed * 1103515245 + 12345) / 65536 % 32768;
        text[i] = 65 + (current_seed % 26);
        if i % 10 == 0 {
            text[i] = 65 + (i / 100);
        }
        if i % 27 == 0 {
            text[i] = 66;
        }
        if i % 42 == 0 {
            text[i] = 67;
        }
        i = i + 1;
    }
}

fn find_pattern(text: &[i32; TEXT_SIZE], pattern: &[i32; PATTERN_SIZE], p_len: i32) -> i32 {
    let mut count: i32 = 0;
    let mut i: i32 = 0;
    while i <= TEXT_SIZE - p_len {
        let mut j: i32 = 0;
        let mut found: bool = true;
        while j < p_len {
            if text[i + j] != pattern[j] {
                found = false;
                break;
            }
            j = j + 1;
        }
        if found {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

fn find_pattern_with_wildcard(text: &[i32; TEXT_SIZE], pattern: &[i32; PATTERN_SIZE], p_len: i32, wildcard: i32) -> i32 {
    let mut count: i32 = 0;
    let mut i: i32 = 0;
    while i <= TEXT_SIZE - p_len {
        let mut j: i32 = 0;
        let mut found: bool = true;
        while j < p_len {
            if pattern[j] != wildcard && text[i + j] != pattern[j] {
                found = false;
                break;
            }
            j = j + 1;
        }
        if found {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}

fn find_complex_pattern(text: &[i32; TEXT_SIZE]) -> i32 {
    let mut count: i32 = 0;
    let mut i: i32 = 0;
    while i < TEXT_SIZE - 5 {
        if text[i] == text[i + 3] && text[i+1] == text[i+4] && text[i] < text[i+2] {
            let mut sum: i32 = 0;
            let mut k: i32 = 0;
            while k < 5 {
                sum = sum + text[i+k];
                k = k + 1;
            }
            if sum > 350 {
                count = count + 1;
            }
        }
        i = i + 1;
    }
    return count;
}

fn analyze_text_frequency(text: &[i32; TEXT_SIZE]) -> i32 {
    let mut freq: [i32; 26] = [0; 26];
    let mut i: i32 = 0;
    while i < TEXT_SIZE {
        let char_code: i32 = text[i];
        if char_code >= 65 && char_code <= 90 {
            freq[char_code - 65] = freq[char_code - 65] + 1;
        }
        i = i + 1;
    }

    let mut max_freq: i32 = 0;
    let mut max_char: i32 = -1;
    i = 0;
    while i < 26 {
        if freq[i] > max_freq {
            max_freq = freq[i];
            max_char = i + 65;
        }
        i = i + 1;
    }
    return max_char * 1000 + max_freq;
}

fn state_machine_search(text: &[i32; TEXT_SIZE]) -> i32 {
    let mut state: i32 = 0;
    let mut count: i32 = 0;
    let mut i: i32 = 0;
    while i < TEXT_SIZE {
        let current_char: i32 = text[i];
        if state == 0 {
            if current_char == 65 {
                state = 1;
            }
        } else if state == 1 {
            if current_char == 66 {
                state = 2;
            } else if current_char != 65 {
                state = 0;
            }
        } else if state == 2 {
            if current_char == 67 {
                state = 3;
            } else if current_char == 65 {
                state = 1;
            } else {
                state = 0;
            }
        } else if state == 3 {
            count = count + 1;
            if current_char == 65 {
                state = 1;
            } else {
                state = 0;
            }
        }
        i = i + 1;
    }
    return count;
}

fn trigger_error_path(text: &[i32; TEXT_SIZE], pattern: &[i32; PATTERN_SIZE], p_len: i32) -> i32 {
    let mut local_text: [i32; TEXT_SIZE] = text;
    let mut i: i32 = 0;
    while i < TEXT_SIZE {
        local_text[i] = local_text[i] + i % 10;
        i = i + 1;
    }

    let mut count: i32 = 0;
    i = 0;
    while i <= TEXT_SIZE - p_len {
        let mut j: i32 = 0;
        let mut match_score: i32 = 0;
        while j < p_len {
            if local_text[i + j] == pattern[j] {
                match_score = match_score + 1;
            }
            j = j + 1;
        }

        if match_score > 0 {
            let mut is_prime: bool = true;
            if match_score < 2 {
                is_prime = false;
            }
            let mut k: i32 = 2;
            while k * k <= match_score {
                if match_score % k == 0 {
                    is_prime = false;
                    break;
                }
                k = k + 1;
            }

            if is_prime {
                count = count + 1;
            }
        }
        i = i + 1;
    }

    let mut another_val: i32 = 0;
    i = 0;
    while i < 100 {
        if i % 3 == 0 {
            another_val = another_val + text[i];
        } else {
            another_val = another_val - text[i];
        }
        i = i + 1;
    }

    let final_result: i32 = count + another_val;
    if final_result > 1000 {
        let intermediate: bool = final_result * 2;
        if intermediate {
            return 1;
        } else {
            return 0;
        }
    }
    return final_result;
}

fn another_level_of_search(text: &[i32; TEXT_SIZE]) {
    let mut pattern: [i32; PATTERN_SIZE] = [0; PATTERN_SIZE];
    let mut i: i32 = 0;
    while i < PATTERN_SIZE {
        pattern[i] = 70 + i % 5;
        i = i + 1;
    }

    let mut pos: i32 = -1;
    i = 0;
    while i < TEXT_SIZE - PATTERN_SIZE {
        let mut found: bool = true;
        let mut j: i32 = 0;
        while j < PATTERN_SIZE {
            if text[i+j] != pattern[j] {
                found = false;
                break;
            }
            j = j + 1;
        }
        if found {
            pos = i;
            break;
        }
        i = i + 1;
    }
    printInt(pos);
}

fn yet_another_search_function() {
    let mut text: [i32; TEXT_SIZE] = [0; TEXT_SIZE];
    generate_text(&mut text, 54321);
    let mut result1: i32 = state_machine_search(&text);
    another_level_of_search(&text);
    printInt(result1);
}
