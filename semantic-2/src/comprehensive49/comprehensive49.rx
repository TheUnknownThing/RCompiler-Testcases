/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Success
Test Name: Advanced Memory Management and Data Structure Simulation
Summary: This test comprehensively evaluates compiler optimizations for:
Details:
Simulation of a custom memory allocator with block splitting and merging
Complex pointer-like integer arithmetic for managing memory blocks
Optimization of multi-dimensional arrays for representing memory heaps
Deeply nested conditional logic for memory allocation and deallocation strategies
Loop-heavy code for searching and manipulating memory blocks
Function call overhead in a recursive memory management scenario
Edge cases in memory management, such as fragmentation and out-of-memory.
*/

// comprehensive49.rx - Advanced Memory Management and Data Structure Simulation
// This test comprehensively evaluates compiler optimizations for:
// - Simulation of a custom memory allocator with block splitting and merging
// - Complex pointer-like integer arithmetic for managing memory blocks
// - Optimization of multi-dimensional arrays for representing memory heaps
// - Deeply nested conditional logic for memory allocation and deallocation strategies
// - Loop-heavy code for searching and manipulating memory blocks
// - Function call overhead in a recursive memory management scenario
// - Edge cases in memory management, such as fragmentation and out-of-memory.

fn main() {
    let mut memory: i32[1024];
    let mut i: i32;
    i = 0;
    while (i < 1024) {
        memory[i] = 0;
        i = i + 1;
    }
    // block format: [is_free, size, prev_block_ptr, next_block_ptr]
    // is_free: 1 for free, 0 for allocated
    memory[0] = 1;
    memory[1] = 1020; // size of block, excluding header
    memory[2] = -1; // prev
    memory[3] = -1; // next

    let mut alloc_ptr1: i32;
    alloc_ptr1 = allocate(memory, 256);
    printInt(alloc_ptr1);

    let mut alloc_ptr2: i32;
    alloc_ptr2 = allocate(memory, 128);
    printInt(alloc_ptr2);

    let mut alloc_ptr3: i32;
    alloc_ptr3 = allocate(memory, 512);
    printInt(alloc_ptr3);

    deallocate(memory, alloc_ptr2);

    let mut alloc_ptr4: i32;
    alloc_ptr4 = allocate(memory, 64);
    printInt(alloc_ptr4);

    deallocate(memory, alloc_ptr1);
    deallocate(memory, alloc_ptr3);

    let mut alloc_ptr5: i32;
    alloc_ptr5 = allocate(memory, 768);
    printInt(alloc_ptr5);

    let mut j: i32;
    j = 0;
    while (j < 10) {
        let mut temp_ptr: i32;
        temp_ptr = allocate(memory, 10);
        if (temp_ptr == -1) {
            // This part of the code has a logic error.
            // The variable `alloc_ptr_invalid` is declared but never used.
            // A different variable `alloc_ptr4` is deallocated instead, which might be a bug.
            let mut alloc_ptr_invalid: i32;
            alloc_ptr_invalid = -1;
            deallocate(memory, alloc_ptr4); // Compile Error: `alloc_ptr4` might be used after deallocation
        }
        j = j + 1;
    }

    print_memory_state(memory);
}

fn allocate(memory: i32[], size: i32) -> i32 {
    let mut current_ptr: i32;
    current_ptr = 0;
    let mut best_fit_ptr: i32;
    best_fit_ptr = -1;
    let mut best_fit_size: i32;
    best_fit_size = 1025; // Larger than any possible block

    while (current_ptr != -1) {
        let is_free: i32;
        is_free = memory[current_ptr];
        let block_size: i32;
        block_size = memory[current_ptr + 1];

        if (is_free == 1) {
            if (block_size >= size) {
                if (block_size < best_fit_size) {
                    best_fit_size = block_size;
                    best_fit_ptr = current_ptr;
                }
            }
        }
        current_ptr = memory[current_ptr + 3];
    }

    if (best_fit_ptr != -1) {
        let block_size: i32;
        block_size = memory[best_fit_ptr + 1];
        let remaining_size: i32;
        remaining_size = block_size - size - 4;

        if (remaining_size > 8) {
            // Split the block
            memory[best_fit_ptr + 1] = size;
            memory[best_fit_ptr] = 0; // Mark as allocated

            let new_block_ptr: i32;
            new_block_ptr = best_fit_ptr + size + 4;
            memory[new_block_ptr] = 1; // is_free
            memory[new_block_ptr + 1] = remaining_size;
            memory[new_block_ptr + 2] = best_fit_ptr; // prev
            memory[new_block_ptr + 3] = memory[best_fit_ptr + 3]; // next

            let original_next_ptr: i32;
            original_next_ptr = memory[best_fit_ptr + 3];
            if (original_next_ptr != -1) {
                memory[original_next_ptr + 2] = new_block_ptr;
            }
            memory[best_fit_ptr + 3] = new_block_ptr;
        } else {
            // Allocate the whole block
            memory[best_fit_ptr] = 0;
        }
        return best_fit_ptr + 4; // Return pointer to data area
    }

    return -1; // No suitable block found
}

fn deallocate(memory: i32[], ptr: i32) {
    if (ptr < 4) {
        return;
    }
    let block_ptr: i32;
    block_ptr = ptr - 4;
    memory[block_ptr] = 1; // Mark as free

    // Try to merge with next block
    let next_block_ptr: i32;
    next_block_ptr = memory[block_ptr + 3];
    if (next_block_ptr != -1) {
        if (memory[next_block_ptr] == 1) {
            let next_block_size: i32;
            next_block_size = memory[next_block_ptr + 1];
            memory[block_ptr + 1] = memory[block_ptr + 1] + next_block_size + 4;
            let next_next_ptr: i32;
            next_next_ptr = memory[next_block_ptr + 3];
            memory[block_ptr + 3] = next_next_ptr;
            if (next_next_ptr != -1) {
                memory[next_next_ptr + 2] = block_ptr;
            }
        }
    }

    // Try to merge with prev block
    let prev_block_ptr: i32;
    prev_block_ptr = memory[block_ptr + 2];
    if (prev_block_ptr != -1) {
        if (memory[prev_block_ptr] == 1) {
            let current_block_size: i32;
            current_block_size = memory[block_ptr + 1];
            memory[prev_block_ptr + 1] = memory[prev_block_ptr + 1] + current_block_size + 4;
            let next_ptr: i32;
            next_ptr = memory[block_ptr + 3];
            memory[prev_block_ptr + 3] = next_ptr;
            if (next_ptr != -1) {
                memory[next_ptr + 2] = prev_block_ptr;
            }
        }
    }
}

fn print_memory_state(memory: i32[]) {
    let mut current_ptr: i32;
    current_ptr = 0;
    let mut total_free: i32;
    total_free = 0;
    let mut total_allocated: i32;
    total_allocated = 0;
    let mut num_fragments: i32;
    num_fragments = 0;

    while (current_ptr != -1) {
        let is_free: i32;
        is_free = memory[current_ptr];
        let block_size: i32;
        block_size = memory[current_ptr + 1];

        if (is_free == 1) {
            total_free = total_free + block_size;
            num_fragments = num_fragments + 1;
        } else {
            total_allocated = total_allocated + block_size;
        }
        current_ptr = memory[current_ptr + 3];
    }
    printInt(total_free);
    printInt(total_allocated);
    printInt(num_fragments);
}

fn deep_recursive_check(memory: i32[], depth: i32, ptr: i32) -> i32 {
    if (depth <= 0) {
        return 1;
    }
    if (ptr == -1) {
        return 0;
    }

    let mut score: i32;
    score = 0;
    let block_size: i32;
    block_size = memory[ptr + 1];

    if (block_size > 100) {
        score = score + deep_recursive_check(memory, depth - 1, memory[ptr + 3]);
    } else {
        score = score + deep_recursive_check(memory, depth - 1, memory[ptr + 2]);
    }
    return score;
}

fn another_utility_function(memory: i32[], start_ptr: i32) -> i32 {
    let mut p: i32;
    p = start_ptr;
    let mut count: i32;
    count = 0;
    while (p != -1) {
        if (memory[p] == 0) { // if allocated
            let mut i: i32;
            i = 0;
            while (i < memory[p + 1]) {
                // A meaningless but complex calculation
                count = count + memory[p + 4 + i] * (i % 3 - 1);
                i = i + 1;
            }
        }
        p = memory[p + 3];
    }
    return count;
}

fn complex_memory_scan(memory: i32[]) -> i32 {
    let mut result: i32;
    result = 0;
    let mut i: i32;
    i = 0;
    while (i < 5) {
        result = result + another_utility_function(memory, i * 10);
        i = i + 1;
    }
    return result;
}
