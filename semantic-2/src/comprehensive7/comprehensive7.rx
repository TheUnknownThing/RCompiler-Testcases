/*
Test Package: Semantic-2
Test Target: comprehensive
Author: Wenxin Zheng
Time: 2025-08-17
Verdict: Success
Test Name: Comprehensive Test 7: Graph Algorithms and Network Analysis
Summary: This test focuses on compiler optimization of:
Details:
Graph traversal algorithm optimizations
Dynamic programming on graphs
Complex nested loop structures in graph algorithms
Path finding algorithm optimizations
Network flow algorithm optimizations
Graph data structure access pattern optimizations
*/

// comprehensive7.rx - Comprehensive Test 7: Graph Algorithms and Network Analysis
// This test focuses on compiler optimization of:
// - Graph traversal algorithm optimizations
// - Dynamic programming on graphs
// - Complex nested loop structures in graph algorithms
// - Path finding algorithm optimizations
// - Network flow algorithm optimizations
// - Graph data structure access pattern optimizations

fn main() {
    // Performance test marker - start
    printInt(1700);
    
    // Test 1: Graph traversal algorithms (DFS, BFS)
    // Tests optimization of recursive and iterative graph traversal
    testGraphTraversalAlgorithms();
    
    // Test 2: Shortest path algorithms
    // Tests optimization of dynamic programming and relaxation operations
    testShortestPathAlgorithms();
    
    // Test 3: Minimum spanning tree algorithms
    // Tests optimization of greedy algorithms and union-find operations
    testMinimumSpanningTreeAlgorithms();
    
    // Test 4: Network flow algorithms
    // Tests optimization of augmenting path algorithms
    testNetworkFlowAlgorithms();
    
    // Test 5: Graph connectivity and components
    // Tests optimization of component detection algorithms
    testGraphConnectivityAlgorithms();
    
    // Performance test marker - end
    printInt(1799);
}

// Test 1: Graph Traversal Algorithms
fn testGraphTraversalAlgorithms() {
    printInt(1701); // Start graph traversal test
    
    // Create adjacency matrix for graph (50x50 nodes)
    let mut graph: [i32; 2500] = [0; 2500];
    initializeGraph(graph, 50);
    
    // Test Depth-First Search
    let dfs_result: i32 = depthFirstSearch(graph, 50, 0);
    printInt(dfs_result);
    
    // Test Breadth-First Search  
    let bfs_result: i32 = breadthFirstSearch(graph, 50, 0);
    printInt(bfs_result);
    
    // Test iterative DFS
    let iterative_dfs_result: i32 = iterativeDepthFirstSearch(graph, 50, 0);
    printInt(iterative_dfs_result);
    
    // Test cycle detection
    let cycle_result: i32 = detectCycles(graph, 50);
    printInt(cycle_result);
    
    printInt(1702); // End graph traversal test
}

// Initialize graph with edges
fn initializeGraph(mut graph: [i32; 2500], size: i32) {
    let mut i: i32 = 0;
    
    // Initialize adjacency matrix to 0
    while (i < size * size) {
        graph[i] = 0;
        i = i + 1;
    }
    
    // Add edges based on pattern
    i = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            // Create connections based on mathematical relationship
            if (i != j && ((i + j) % 7 == 0 || (i * j) % 11 == 0)) {
                graph[i * size + j] = 1 + (i + j) % 10; // Edge weight
                graph[j * size + i] = 1 + (i + j) % 10; // Make undirected
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

// Depth-First Search (recursive)
fn depthFirstSearch(graph: [i32; 2500], size: i32, start: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    return dfsRecursive(graph, size, start, visited);
}

fn dfsRecursive(graph: [i32; 2500], size: i32, node: i32, mut visited: [bool; 50]) -> i32 {
    visited[node] = true;
    let mut nodes_visited: i32 = 1;
    
    let mut neighbor: i32 = 0;
    while (neighbor < size) {
        if (graph[node * size + neighbor] > 0 && !visited[neighbor]) {
            nodes_visited = nodes_visited + dfsRecursive(graph, size, neighbor, visited);
        }
        neighbor = neighbor + 1;
    }
    
    return nodes_visited;
}

// Breadth-First Search (iterative with queue simulation)
fn breadthFirstSearch(graph: [i32; 2500], size: i32, start: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut queue: [i32; 50] = [-1; 50];
    let mut queue_front: i32 = 0;
    let mut queue_rear: i32 = 0;
    let mut nodes_visited: i32 = 0;
    
    // Enqueue start node
    queue[queue_rear] = start;
    queue_rear = queue_rear + 1;
    visited[start] = true;
    
    while (queue_front < queue_rear) {
        let current_node: i32 = queue[queue_front];
        queue_front = queue_front + 1;
        nodes_visited = nodes_visited + 1;
        
        // Visit all unvisited neighbors
        let mut neighbor: i32 = 0;
        while (neighbor < size) {
            if (graph[current_node * size + neighbor] > 0 && !visited[neighbor]) {
                visited[neighbor] = true;
                queue[queue_rear] = neighbor;
                queue_rear = queue_rear + 1;
            }
            neighbor = neighbor + 1;
        }
    }
    
    return nodes_visited;
}

// Iterative Depth-First Search using stack
fn iterativeDepthFirstSearch(graph: [i32; 2500], size: i32, start: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut stack: [i32; 50] = [-1; 50];
    let mut stack_top: i32 = 0;
    let mut nodes_visited: i32 = 0;
    
    // Push start node onto stack
    stack[stack_top] = start;
    stack_top = stack_top + 1;
    
    while (stack_top > 0) {
        // Pop node from stack
        stack_top = stack_top - 1;
        let current_node: i32 = stack[stack_top];
        
        if (!visited[current_node]) {
            visited[current_node] = true;
            nodes_visited = nodes_visited + 1;
            
            // Push all unvisited neighbors onto stack
            let mut neighbor: i32 = 0;
            while (neighbor < size) {
                if (graph[current_node * size + neighbor] > 0 && !visited[neighbor]) {
                    stack[stack_top] = neighbor;
                    stack_top = stack_top + 1;
                }
                neighbor = neighbor + 1;
            }
        }
    }
    
    return nodes_visited;
}

// Detect cycles in graph using DFS
fn detectCycles(graph: [i32; 2500], size: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut in_recursion_stack: [bool; 50] = [false; 50];
    let mut cycles_found: i32 = 0;
    
    let mut i: i32 = 0;
    while (i < size) {
        if (!visited[i]) {
            if (dfsCycleDetection(graph, size, i, visited, in_recursion_stack)) {
                cycles_found = cycles_found + 1;
            }
        }
        i = i + 1;
    }
    
    return cycles_found;
}

fn dfsCycleDetection(graph: [i32; 2500], size: i32, node: i32, 
                    mut visited: [bool; 50], mut in_recursion_stack: [bool; 50]) -> bool {
    visited[node] = true;
    in_recursion_stack[node] = true;
    
    let mut neighbor: i32 = 0;
    while (neighbor < size) {
        if (graph[node * size + neighbor] > 0) {
            if (!visited[neighbor]) {
                if (dfsCycleDetection(graph, size, neighbor, visited, in_recursion_stack)) {
                    return true;
                }
            } else if (in_recursion_stack[neighbor]) {
                return true;
            }
        }
        neighbor = neighbor + 1;
    }
    
    in_recursion_stack[node] = false;
    return false;
}

// Test 2: Shortest Path Algorithms
fn testShortestPathAlgorithms() {
    printInt(1703); // Start shortest path test
    
    let mut graph: [i32; 2500] = [0; 2500];
    initializeWeightedGraph(graph, 50);
    
    // Test Dijkstra's algorithm
    let dijkstra_result: i32 = dijkstraShortestPath(graph, 50, 0);
    printInt(dijkstra_result);
    
    // Test Floyd-Warshall algorithm (limited size)
    let floyd_result: i32 = floydWarshallAllPairs(graph, 20);
    printInt(floyd_result);
    
    // Test Bellman-Ford algorithm
    let bellman_result: i32 = bellmanFordShortestPath(graph, 50, 0);
    printInt(bellman_result);
    
    printInt(1704); // End shortest path test
}

// Initialize weighted graph
fn initializeWeightedGraph(mut graph: [i32; 2500], size: i32) {
    let mut i: i32 = 0;
    
    // Initialize with infinity (represented by 9999)
    while (i < size * size) {
        graph[i] = 9999;
        i = i + 1;
    }
    
    // Set diagonal to 0 (distance from node to itself)
    i = 0;
    while (i < size) {
        graph[i * size + i] = 0;
        i = i + 1;
    }
    
    // Add weighted edges
    i = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            if (i != j && ((i + j) % 5 == 0 || (i * 2 + j) % 7 == 0)) {
                let weight: i32 = 1 + ((i + j) % 15);
                graph[i * size + j] = weight;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

// Dijkstra's shortest path algorithm
fn dijkstraShortestPath(graph: [i32; 2500], size: i32, start: i32) -> i32 {
    let mut distances: [i32; 50] = [9999; 50];
    let mut visited: [bool; 50] = [false; 50];
    let mut total_distance: i32 = 0;
    
    distances[start] = 0;
    
    let mut count: i32 = 0;
    while (count < size) {
        // Find minimum distance unvisited node
        let mut min_distance: i32 = 9999;
        let mut min_node: i32 = -1;
        let mut i: i32 = 0;
        
        while (i < size) {
            if (!visited[i] && distances[i] < min_distance) {
                min_distance = distances[i];
                min_node = i;
            }
            i = i + 1;
        }
        
        if (min_node == -1) {
            break;
        }
        
        visited[min_node] = true;
        total_distance = total_distance + distances[min_node];
        
        // Update distances to neighbors
        i = 0;
        while (i < size) {
            if (!visited[i] && graph[min_node * size + i] != 9999) {
                let new_distance: i32 = distances[min_node] + graph[min_node * size + i];
                if (new_distance < distances[i]) {
                    distances[i] = new_distance;
                }
            }
            i = i + 1;
        }
        
        count = count + 1;
    }
    
    return total_distance;
}

// Floyd-Warshall all-pairs shortest path
fn floydWarshallAllPairs(mut graph: [i32; 2500], size: i32) -> i32 {
    // Create distance matrix (limited to 20x20 for performance)
    let actual_size: i32;
    if (size > 20) {
        actual_size = 20;
    } else {
        actual_size = size;
    }
    
    let mut distances: [i32; 400] = [9999; 400];
    
    // Initialize distances
    let mut i: i32 = 0;
    while (i < actual_size) {
        let mut j: i32 = 0;
        while (j < actual_size) {
            distances[i * actual_size + j] = graph[i * size + j];
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Floyd-Warshall main loop
    let mut k: i32 = 0;
    while (k < actual_size) {
        i = 0;
        while (i < actual_size) {
            let mut j: i32 = 0;
            while (j < actual_size) {
                if (distances[i * actual_size + k] != 9999 && 
                   distances[k * actual_size + j] != 9999) {
                    let new_distance: i32 = distances[i * actual_size + k] + distances[k * actual_size + j];
                    if (new_distance < distances[i * actual_size + j]) {
                        distances[i * actual_size + j] = new_distance;
                    }
                }
                j = j + 1;
            }
            i = i + 1;
        }
        k = k + 1;
    }
    
    // Sum all shortest paths
    let mut total_distance: i32 = 0;
    i = 0;
    while (i < actual_size) {
        let mut j: i32 = 0;
        while (j < actual_size) {
            if (i != j && distances[i * actual_size + j] != 9999) {
                total_distance = total_distance + distances[i * actual_size + j];
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    return total_distance;
}

// Bellman-Ford shortest path algorithm
fn bellmanFordShortestPath(graph: [i32; 2500], size: i32, start: i32) -> i32 {
    let mut distances: [i32; 50] = [9999; 50];
    distances[start] = 0;
    
    // Relax edges size-1 times
    let mut iteration: i32 = 0;
    while (iteration < size - 1) {
        let mut i: i32 = 0;
        while (i < size) {
            let mut j: i32 = 0;
            while (j < size) {
                if (graph[i * size + j] != 9999 && distances[i] != 9999) {
                    let new_distance: i32 = distances[i] + graph[i * size + j];
                    if new_distance < distances[j] {
                        distances[j] = new_distance;
                    }
                }
                j = j + 1;
            }
            i = i + 1;
        }
        iteration = iteration + 1;
    }
    
    // Check for negative cycles (one more iteration)
    let mut negative_cycles: i32 = 0;
    let mut i: i32 = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            if graph[i * size + j] != 9999 && distances[i] != 9999 {
                let new_distance: i32 = distances[i] + graph[i * size + j];
                if new_distance < distances[j] {
                    negative_cycles = negative_cycles + 1;
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Return sum of all distances
    let mut total_distance: i32 = 0;
    i = 0;
    while (i < size) {
        if distances[i] != 9999 {
            total_distance = total_distance + distances[i];
        }
        i = i + 1;
    }
    
    return total_distance + negative_cycles;
}

// Test 3: Minimum Spanning Tree Algorithms
fn testMinimumSpanningTreeAlgorithms() {
    printInt(1705); // Start MST test
    
    let mut graph: [i32; 2500] = [0; 2500];
    initializeWeightedGraph(graph, 50);
    
    // Test Kruskal's algorithm
    let kruskal_result: i32 = kruskalMST(graph, 50);
    printInt(kruskal_result);
    
    // Test Prim's algorithm
    let prim_result: i32 = primMST(graph, 50);
    printInt(prim_result);
    
    printInt(1706); // End MST test
}

// Kruskal's MST algorithm (simplified without Union-Find)
fn kruskalMST(graph: [i32; 2500], size: i32) -> i32 {
    // Create edge list
    let mut edges: [i32; 1500] = [0; 1500]; // [weight, src, dest] triplets
    let mut edge_count: i32 = 0;
    
    // Extract edges from adjacency matrix
    let mut i: i32 = 0;
    while (i < size && edge_count < 500) {
        let mut j: i32 = i + 1;
        while (j < size && edge_count < 500) {
            if graph[i * size + j] != 9999 && graph[i * size + j] != 0 {
                edges[edge_count * 3] = graph[i * size + j]; // weight
                edges[edge_count * 3 + 1] = i; // source
                edges[edge_count * 3 + 2] = j; // destination
                edge_count = edge_count + 1;
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Sort edges by weight (simple bubble sort)
    sortEdgesByWeight(edges, edge_count);
    
    // Build MST using simple cycle detection
    let mut mst_weight: i32 = 0;
    let mut mst_edges: i32 = 0;
    let mut edge_index: i32 = 0;
    
    while (edge_index < edge_count && mst_edges < size - 1) {
        let weight: i32 = edges[edge_index * 3];
        let src: i32 = edges[edge_index * 3 + 1];
        let dest: i32 = edges[edge_index * 3 + 2];
        
        // Simple check: add edge if it doesn't create obvious cycles
        if src != dest {
            mst_weight = mst_weight + weight;
            mst_edges = mst_edges + 1;
        }
        
        edge_index = edge_index + 1;
    }
    
    return mst_weight;
}

// Sort edges by weight using bubble sort
fn sortEdgesByWeight(mut edges: [i32; 1500], edge_count: i32) {
    let mut i: i32 = 0;
    while (i < edge_count - 1) {
        let mut j: i32 = 0;
        while (j < edge_count - i - 1) {
            if edges[j * 3] > edges[(j + 1) * 3] {
                // Swap edges
                let temp_weight: i32 = edges[j * 3];
                let temp_src: i32 = edges[j * 3 + 1];
                let temp_dest: i32 = edges[j * 3 + 2];
                
                edges[j * 3] = edges[(j + 1) * 3];
                edges[j * 3 + 1] = edges[(j + 1) * 3 + 1];
                edges[j * 3 + 2] = edges[(j + 1) * 3 + 2];
                
                edges[(j + 1) * 3] = temp_weight;
                edges[(j + 1) * 3 + 1] = temp_src;
                edges[(j + 1) * 3 + 2] = temp_dest;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}

// Prim's MST algorithm
fn primMST(graph: [i32; 2500], size: i32) -> i32 {
    let mut key: [i32; 50] = [9999; 50];
    let mut mst_set: [bool; 50] = [false; 50];
    let mut mst_weight: i32 = 0;
    
    key[0] = 0; // Start from vertex 0
    
    let mut count: i32 = 0;
    while (count < size) {
        // Find minimum key vertex not in MST
        let mut min_key: i32 = 9999;
        let mut min_index: i32 = -1;
        let mut v: i32 = 0;
        
        while (v < size) {
            if !mst_set[v] && key[v] < min_key {
                min_key = key[v];
                min_index = v;
            }
            v = v + 1;
        }
        
        if min_index == -1 {
            break;
        }
        
        mst_set[min_index] = true;
        mst_weight = mst_weight + key[min_index];
        
        // Update key values of adjacent vertices
        v = 0;
        while (v < size) {
            if !mst_set[v] && graph[min_index * size + v] != 9999 && 
               graph[min_index * size + v] != 0 && graph[min_index * size + v] < key[v] {
                key[v] = graph[min_index * size + v];
            }
            v = v + 1;
        }
        
        count = count + 1;
    }
    
    return mst_weight;
}

// Test 4: Network Flow Algorithms
fn testNetworkFlowAlgorithms() {
    printInt(1707); // Start network flow test
    
    let mut capacity: [i32; 900] = [0; 900]; // 30x30 capacity matrix
    initializeFlowNetwork(capacity, 30);
    
    // Test Ford-Fulkerson max flow
    let max_flow_result: i32 = fordFulkersonMaxFlow(capacity, 30, 0, 29);
    printInt(max_flow_result);
    
    // Test min-cost max flow (simplified)
    let min_cost_result: i32 = minCostMaxFlow(capacity, 30);
    printInt(min_cost_result);
    
    printInt(1708); // End network flow test
}

// Initialize flow network
fn initializeFlowNetwork(mut capacity: [i32; 900], size: i32) {
    let mut i: i32 = 0;
    
    // Initialize all capacities to 0
    while (i < size * size) {
        capacity[i] = 0;
        i = i + 1;
    }
    
    // Add capacity based on network topology
    i = 0;
    while (i < size - 1) {
        // Forward edges
        capacity[i * size + (i + 1)] = 10 + (i % 20);
        
        // Some cross edges
        if i + 5 < size {
            capacity[i * size + (i + 5)] = 5 + (i % 10);
        }
        
        // Some backward connections for complex flow
        if i > 5 {
            capacity[i * size + (i - 3)] = 3 + (i % 7);
        }
        
        i = i + 1;
    }
}

// Ford-Fulkerson max flow algorithm
fn fordFulkersonMaxFlow(mut capacity: [i32; 900], size: i32, source: i32, sink: i32) -> i32 {
    let mut residual: [i32; 900] = [0; 900];
    let mut max_flow: i32 = 0;
    
    // Initialize residual graph
    let mut i: i32 = 0;
    while (i < size * size) {
        residual[i] = capacity[i];
        i = i + 1;
    }
    
    // Find augmenting paths
    let mut iteration: i32 = 0;
    while (iteration < 100) { // Limit iterations
        let mut parent: [i32; 30] = [-1; 30];
        let flow: i32 = bfsAugmentingPath(residual, size, source, sink, parent);
        
        if flow == 0 {
            break; // No more augmenting paths
        }
        
        max_flow = max_flow + flow;
        
        // Update residual graph
        let mut v: i32 = sink;
        while (v != source) {
            let u: i32 = parent[v];
            residual[u * size + v] = residual[u * size + v] - flow;
            residual[v * size + u] = residual[v * size + u] + flow;
            v = parent[v];
        }
        
        iteration = iteration + 1;
    }
    
    return max_flow;
}

// BFS to find augmenting path
fn bfsAugmentingPath(residual: [i32; 900], size: i32, source: i32, sink: i32, mut parent: [i32; 30]) -> i32 {
    let mut visited: [bool; 30] = [false; 30];
    let mut queue: [i32; 30] = [-1; 30];
    let mut queue_front: i32 = 0;
    let mut queue_rear: i32 = 0;
    
    queue[queue_rear] = source;
    queue_rear = queue_rear + 1;
    visited[source] = true;
    parent[source] = -1;
    
    while (queue_front < queue_rear) {
        let u: i32 = queue[queue_front];
        queue_front = queue_front + 1;
        
        let mut v: i32 = 0;
        while (v < size) {
            if !visited[v] && residual[u * size + v] > 0 {
                queue[queue_rear] = v;
                queue_rear = queue_rear + 1;
                visited[v] = true;
                parent[v] = u;
                
                if v == sink {
                    // Found path to sink, calculate bottleneck capacity
                    let mut path_flow: i32 = 9999;
                    let mut current: i32 = sink;
                    
                    while (current != source) {
                        let prev: i32 = parent[current];
                        if residual[prev * size + current] < path_flow {
                            path_flow = residual[prev * size + current];
                        }
                        current = prev;
                    }
                    
                    return path_flow;
                }
            }
            v = v + 1;
        }
    }
    
    return 0; // No augmenting path found
}

// Simplified min-cost max flow
fn minCostMaxFlow(capacity: [i32; 900], size: i32) -> i32 {
    let mut total_cost: i32 = 0;
    let mut total_flow: i32 = 0;
    
    // Simple cost calculation based on distance
    let mut i: i32 = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            if capacity[i * size + j] > 0 {
                let distance: i32;
                if i > j {
                    distance = i - j;
                } else {
                    distance = j - i;
                }
                total_cost = total_cost + capacity[i * size + j] * distance;
                total_flow = total_flow + capacity[i * size + j];
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    return total_cost / (total_flow + 1); // Average cost per unit flow
}

// Test 5: Graph Connectivity Algorithms
fn testGraphConnectivityAlgorithms() {
    printInt(1709); // Start connectivity test
    
    let mut graph: [i32; 2500] = [0; 2500];
    initializeGraph(graph, 50);
    
    // Test connected components
    let components_result: i32 = findConnectedComponents(graph, 50);
    printInt(components_result);
    
    // Test strongly connected components (for directed graph)
    let scc_result: i32 = findStronglyConnectedComponents(graph, 50);
    printInt(scc_result);
    
    // Test articulation points
    let articulation_result: i32 = findArticulationPoints(graph, 50);
    printInt(articulation_result);
    
    // Test bridges
    let bridges_result: i32 = findBridges(graph, 50);
    printInt(bridges_result);
    
    printInt(1710); // End connectivity test
}

// Find connected components using DFS
fn findConnectedComponents(graph: [i32; 2500], size: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut components: i32 = 0;
    
    let mut i: i32 = 0;
    while (i < size) {
        if !visited[i] {
            dfsComponentTraversal(graph, size, i, visited);
            components = components + 1;
        }
        i = i + 1;
    }
    
    return components;
}

fn dfsComponentTraversal(graph: [i32; 2500], size: i32, node: i32, mut visited: [bool; 50]) {
    visited[node] = true;
    
    let mut neighbor: i32 = 0;
    while (neighbor < size) {
        if graph[node * size + neighbor] > 0 && !visited[neighbor] {
            dfsComponentTraversal(graph, size, neighbor, visited);
        }
        neighbor = neighbor + 1;
    }
}

// Find strongly connected components using Kosaraju's algorithm
fn findStronglyConnectedComponents(graph: [i32; 2500], size: i32) -> i32 {
    let mut visited: [bool; 50] = [false; 50];
    let mut finish_order: [i32; 50] = [0; 50];
    let mut finish_index: i32 = 0;
    
    // First DFS to get finish times
    let mut i: i32 = 0;
    while (i < size) {
        if !visited[i] {
            dfsFinishTime(graph, size, i, visited, finish_order, &mut finish_index);
        }
        i = i + 1;
    }
    
    // Create transpose graph
    let mut transpose: [i32; 2500] = [0; 2500];
    i = 0;
    while (i < size) {
        let mut j: i32 = 0;
        while (j < size) {
            transpose[j * size + i] = graph[i * size + j];
            j = j + 1;
        }
        i = i + 1;
    }
    
    // Reset visited array
    i = 0;
    while (i < size) {
        visited[i] = false;
        i = i + 1;
    }
    
    // Second DFS on transpose graph in reverse finish order
    let mut scc_count: i32 = 0;
    i = finish_index - 1;
    while (i >= 0) {
        let node: i32 = finish_order[i];
        if !visited[node] {
            dfsComponentTraversal(transpose, size, node, visited);
            scc_count = scc_count + 1;
        }
        i = i - 1;
    }
    
    return scc_count;
}

fn dfsFinishTime(graph: [i32; 2500], size: i32, node: i32, mut visited: [bool; 50], 
                mut finish_order: [i32; 50], finish_index: &mut i32) {
    visited[node] = true;
    
    let mut neighbor: i32 = 0;
    while (neighbor < size) {
        if graph[node * size + neighbor] > 0 && !visited[neighbor] {
            dfsFinishTime(graph, size, neighbor, visited, finish_order, finish_index);
        }
        neighbor = neighbor + 1;
    }
    
    finish_order[*finish_index] = node;
    *finish_index = *finish_index + 1;
}

// Find articulation points (simplified)
fn findArticulationPoints(graph: [i32; 2500], size: i32) -> i32 {
    let mut articulation_points: i32 = 0;
    
    // For each vertex, temporarily remove it and check connectivity
    let mut vertex: i32 = 0;
    while (vertex < size) {
        let original_components: i32 = findConnectedComponents(graph, size);
        
        // Temporarily remove vertex by setting its edges to 0
        let mut temp_edges: [i32; 50] = [0; 50];
        let mut i: i32 = 0;
        while (i < size) {
            temp_edges[i] = graph[vertex * size + i];
            graph[vertex * size + i] = 0;
            graph[i * size + vertex] = 0;
            i = i + 1;
        }
        
        let new_components: i32 = findConnectedComponents(graph, size);
        
        // Restore edges
        i = 0;
        while (i < size) {
            graph[vertex * size + i] = temp_edges[i];
            graph[i * size + vertex] = temp_edges[i];
            i = i + 1;
        }
        
        if new_components > original_components {
            articulation_points = articulation_points + 1;
        }
        
        vertex = vertex + 1;
    }
    
    return articulation_points;
}

// Find bridges (simplified)
fn findBridges(graph: [i32; 2500], size: i32) -> i32 {
    let mut bridges: i32 = 0;
    
    // For each edge, temporarily remove it and check connectivity
    let mut i: i32 = 0;
    while (i < size) {
        let mut j: i32 = i + 1;
        while (j < size) {
            if graph[i * size + j] > 0 {
                let original_components: i32 = findConnectedComponents(graph, size);
                
                // Temporarily remove edge
                let temp_weight: i32 = graph[i * size + j];
                graph[i * size + j] = 0;
                graph[j * size + i] = 0;
                
                let new_components: i32 = findConnectedComponents(graph, size);
                
                // Restore edge
                graph[i * size + j] = temp_weight;
                graph[j * size + i] = temp_weight;
                
                if new_components > original_components {
                    bridges = bridges + 1;
                }
            }
            j = j + 1;
        }
        i = i + 1;
    }
    
    return bridges;
}
